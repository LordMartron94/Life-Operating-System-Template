/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WikipediaSearchPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian13 = require("obsidian");

// src/commands/linkArticles.ts
var import_obsidian6 = require("obsidian");

// src/utils/searchModal.ts
var import_obsidian2 = require("obsidian");

// src/utils/languages.ts
var languages = {
  aa: "Qaf\xE1r af",
  ab: "\u0430\u0525\u0441\u0448\u04D9\u0430",
  ace: "Ac\xE8h",
  ady: "\u0430\u0434\u044B\u0433\u0430\u0431\u0437\u044D",
  af: "Afrikaans",
  ak: "Akan",
  als: "Alemannisch",
  alt: "\u0430\u043B\u0442\u0430\u0439 \u0442\u0438\u043B",
  am: "\u12A0\u121B\u122D\u129B",
  ami: "Pangcah",
  an: "aragon\xE9s",
  ang: "\xC6nglisc",
  ar: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629",
  arc: "\u0710\u072A\u0721\u071D\u0710",
  ary: "\u0627\u0644\u062F\u0627\u0631\u062C\u0629",
  arz: "\u0645\u0635\u0631\u0649",
  as: "\u0985\u09B8\u09AE\u09C0\u09AF\u09BC\u09BE",
  ast: "asturianu",
  atj: "Atikamekw",
  av: "\u0430\u0432\u0430\u0440",
  avk: "Kotava",
  awa: "\u0905\u0935\u0927\u0940",
  ay: "Aymar aru",
  az: "az\u0259rbaycanca",
  azb: "\u062A\u06C6\u0631\u06A9\u062C\u0647",
  ba: "\u0431\u0430\u0448\u04A1\u043E\u0440\u0442\u0441\u0430",
  ban: "Basa Bali",
  bar: "Boarisch",
  "bat-smg": "\u017Eemait\u0117\u0161ka",
  bcl: "Bikol Central",
  be: "\u0431\u0435\u043B\u0430\u0440\u0443\u0441\u043A\u0430\u044F",
  "be-tarask": "\u0431\u0435\u043B\u0430\u0440\u0443\u0441\u043A\u0430\u044F (\u0442\u0430\u0440\u0430\u0448\u043A\u0435\u0432\u0456\u0446\u0430)",
  "be-x-old": "\u0431\u0435\u043B\u0430\u0440\u0443\u0441\u043A\u0430\u044F (\u0442\u0430\u0440\u0430\u0448\u043A\u0435\u0432\u0456\u0446\u0430)",
  bg: "\u0431\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438",
  bh: "\u092D\u094B\u091C\u092A\u0941\u0930\u0940",
  bi: "Bislama",
  bjn: "Banjar",
  blk: "\u1015\u1021\u102D\u102F\u101D\u103A\u108F\u1018\u102C\u108F\u101E\u102C\u108F",
  bm: "bamanankan",
  bn: "\u09AC\u09BE\u0982\u09B2\u09BE",
  bo: "\u0F56\u0F7C\u0F51\u0F0B\u0F61\u0F72\u0F42",
  bpy: "\u09AC\u09BF\u09B7\u09CD\u09A3\u09C1\u09AA\u09CD\u09B0\u09BF\u09AF\u09BC\u09BE \u09AE\u09A3\u09BF\u09AA\u09C1\u09B0\u09C0",
  br: "brezhoneg",
  bs: "bosanski",
  bug: "\u1A05\u1A14 \u1A15\u1A18\u1A01\u1A17",
  bxr: "\u0431\u0443\u0440\u044F\u0430\u0434",
  ca: "catal\xE0",
  "cbk-zam": "Chavacano de Zamboanga",
  cdo: "\u95A9\u6771\u8A9E / M\xECng-d\u0115\u0324ng-ng\u1E73\u0304",
  ce: "\u043D\u043E\u0445\u0447\u0438\u0439\u043D",
  ceb: "Cebuano",
  ch: "Chamoru",
  cho: "Chahta Anumpa",
  chr: "\u13E3\u13B3\u13A9",
  chy: "Tsets\xEAhest\xE2hese",
  ckb: "\u06A9\u0648\u0631\u062F\u06CC",
  co: "corsu",
  cr: "N\u0113hiyaw\u0113win / \u14C0\u1426\u1403\u152D\u140D\u140F\u1423",
  crh: "q\u0131r\u0131mtatarca",
  cs: "\u010De\u0161tina",
  csb: "kasz\xEBbsczi",
  cu: "\u0441\u043B\u043E\u0432\u0463\u043D\u044C\u0441\u043A\u044A / \u2C14\u2C0E\u2C11\u2C02\u2C21\u2C10\u2C20\u2C14\u2C0D\u2C1F",
  cv: "\u0447\u04D1\u0432\u0430\u0448\u043B\u0430",
  cy: "Cymraeg",
  da: "dansk",
  dag: "dagbanli",
  de: "Deutsch",
  din: "Thu\u0254\u014Bj\xE4\u014B",
  diq: "Zazaki",
  dsb: "dolnoserbski",
  dty: "\u0921\u094B\u091F\u0947\u0932\u0940",
  dv: "\u078B\u07A8\u0788\u07AC\u0780\u07A8\u0784\u07A6\u0790\u07B0",
  dz: "\u0F47\u0F7C\u0F44\u0F0B\u0F41",
  ee: "e\u028Begbe",
  el: "\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC",
  eml: "emili\xE0n e rumagn\xF2l",
  en: "English",
  eo: "Esperanto",
  es: "espa\xF1ol",
  et: "eesti",
  eu: "euskara",
  ext: "estreme\xF1u",
  fa: "\u0641\u0627\u0631\u0633\u06CC",
  ff: "Fulfulde",
  fi: "suomi",
  "fiu-vro": "v\xF5ro",
  fj: "Na Vosa Vakaviti",
  fo: "f\xF8royskt",
  fr: "fran\xE7ais",
  frp: "arpetan",
  frr: "Nordfriisk",
  fur: "furlan",
  fy: "Frysk",
  ga: "Gaeilge",
  gag: "Gagauz",
  gan: "\u8D1B\u8A9E",
  gcr: "kriy\xF2l gwiyannen",
  gd: "G\xE0idhlig",
  gl: "galego",
  glk: "\u06AF\u06CC\u0644\u06A9\u06CC",
  gn: "Ava\xF1e'\u1EBD",
  gom: "\u0917\u094B\u0902\u092F\u091A\u0940 \u0915\u094B\u0902\u0915\u0923\u0940 / G\xF5ychi Konknni",
  gor: "Bahasa Hulontalo",
  got: "\u{10332}\u{1033F}\u{10344}\u{10339}\u{10343}\u{1033A}",
  gu: "\u0A97\u0AC1\u0A9C\u0AB0\u0ABE\u0AA4\u0AC0",
  guc: "wayuunaiki",
  gur: "farefare",
  guw: "gungbe",
  gv: "Gaelg",
  ha: "Hausa",
  hak: "\u5BA2\u5BB6\u8A9E/Hak-k\xE2-ng\xEE",
  haw: "Hawai\u02BBi",
  he: "\u05E2\u05D1\u05E8\u05D9\u05EA",
  hi: "\u0939\u093F\u0928\u094D\u0926\u0940",
  hif: "Fiji Hindi",
  ho: "Hiri Motu",
  hr: "hrvatski",
  hsb: "hornjoserbsce",
  ht: "Krey\xF2l ayisyen",
  hu: "magyar",
  hy: "\u0570\u0561\u0575\u0565\u0580\u0565\u0576",
  hyw: "\u0531\u0580\u0565\u0582\u0574\u057F\u0561\u0570\u0561\u0575\u0565\u0580\u0567\u0576",
  hz: "Otsiherero",
  ia: "interlingua",
  id: "Bahasa Indonesia",
  ie: "Interlingue",
  ig: "Igbo",
  ii: "\uA187\uA259",
  ik: "I\xF1upiatun",
  ilo: "Ilokano",
  inh: "\u0433\u04C0\u0430\u043B\u0433\u04C0\u0430\u0439",
  io: "Ido",
  is: "\xEDslenska",
  it: "italiano",
  iu: "\u1403\u14C4\u1483\u144E\u1450\u1466 / inuktitut",
  ja: "\u65E5\u672C\u8A9E",
  jam: "Patois",
  jbo: "la .lojban.",
  jv: "Jawa",
  ka: "\u10E5\u10D0\u10E0\u10D7\u10E3\u10DA\u10D8",
  kaa: "Qaraqalpaqsha",
  kab: "Taqbaylit",
  kbd: "\u0430\u0434\u044B\u0433\u044D\u0431\u0437\u044D",
  kbp: "Kab\u0269y\u025B",
  kcg: "Tyap",
  kg: "Kongo",
  ki: "G\u0129k\u0169y\u0169",
  kj: "Kwanyama",
  kk: "\u049B\u0430\u0437\u0430\u049B\u0448\u0430",
  kl: "kalaallisut",
  km: "\u1797\u17B6\u179F\u17B6\u1781\u17D2\u1798\u17C2\u179A",
  kn: "\u0C95\u0CA8\u0CCD\u0CA8\u0CA1",
  ko: "\uD55C\uAD6D\uC5B4",
  koi: "\u043F\u0435\u0440\u0435\u043C \u043A\u043E\u043C\u0438",
  kr: "kanuri",
  krc: "\u043A\u044A\u0430\u0440\u0430\u0447\u0430\u0439-\u043C\u0430\u043B\u043A\u044A\u0430\u0440",
  ks: "\u0915\u0949\u0936\u0941\u0930 / \u06A9\u0672\u0634\u064F\u0631",
  ksh: "Ripoarisch",
  ku: "kurd\xEE",
  kv: "\u043A\u043E\u043C\u0438",
  kw: "kernowek",
  ky: "\u043A\u044B\u0440\u0433\u044B\u0437\u0447\u0430",
  la: "Latina",
  lad: "Ladino",
  lb: "L\xEBtzebuergesch",
  lbe: "\u043B\u0430\u043A\u043A\u0443",
  lez: "\u043B\u0435\u0437\u0433\u0438",
  lfn: "Lingua Franca Nova",
  lg: "Luganda",
  li: "Limburgs",
  lij: "Ligure",
  lld: "Ladin",
  lmo: "lombard",
  ln: "ling\xE1la",
  lo: "\u0EA5\u0EB2\u0EA7",
  lrc: "\u0644\u06CA\u0631\u06CC \u0634\u0648\u0645\u0627\u0644\u06CC",
  lt: "lietuvi\u0173",
  ltg: "latga\u013Cu",
  lv: "latvie\u0161u",
  mad: "Madhur\xE2",
  mai: "\u092E\u0948\u0925\u093F\u0932\u0940",
  "map-bms": "Basa Banyumasan",
  mdf: "\u043C\u043E\u043A\u0448\u0435\u043D\u044C",
  mg: "Malagasy",
  mh: "Ebon",
  mhr: "\u043E\u043B\u044B\u043A \u043C\u0430\u0440\u0438\u0439",
  mi: "M\u0101ori",
  min: "Minangkabau",
  mk: "\u043C\u0430\u043A\u0435\u0434\u043E\u043D\u0441\u043A\u0438",
  ml: "\u0D2E\u0D32\u0D2F\u0D3E\u0D33\u0D02",
  mn: "\u043C\u043E\u043D\u0433\u043E\u043B",
  mni: "\uABC3\uABE4\uABC7\uABE9 \uABC2\uABE3\uABDF",
  mnw: "\u1018\u102C\u101E\u102C \u1019\u1014\u103A",
  mo: "\u043C\u043E\u043B\u0434\u043E\u0432\u0435\u043D\u044F\u0441\u043A\u044D",
  mr: "\u092E\u0930\u093E\u0920\u0940",
  mrj: "\u043A\u044B\u0440\u044B\u043A \u043C\u0430\u0440\u044B",
  ms: "Bahasa Melayu",
  mt: "Malti",
  mus: "Mvskoke",
  mwl: "Mirand\xE9s",
  my: "\u1019\u103C\u1014\u103A\u1019\u102C\u1018\u102C\u101E\u102C",
  myv: "\u044D\u0440\u0437\u044F\u043D\u044C",
  mzn: "\u0645\u0627\u0632\u0650\u0631\u0648\u0646\u06CC",
  na: "Dorerin Naoero",
  nah: "N\u0101huatl",
  nap: "Napulitano",
  nds: "Plattd\xFC\xFCtsch",
  "nds-nl": "Nedersaksies",
  ne: "\u0928\u0947\u092A\u093E\u0932\u0940",
  new: "\u0928\u0947\u092A\u093E\u0932 \u092D\u093E\u0937\u093E",
  ng: "Oshiwambo",
  nia: "Li Niha",
  nl: "Nederlands",
  nn: "norsk nynorsk",
  no: "norsk",
  nov: "Novial",
  nqo: "\u07D2\u07DE\u07CF",
  nrm: "Nouormand",
  nso: "Sesotho sa Leboa",
  nv: "Din\xE9 bizaad",
  ny: "Chi-Chewa",
  oc: "occitan",
  olo: "livvinkarjala",
  om: "Oromoo",
  or: "\u0B13\u0B21\u0B3C\u0B3F\u0B06",
  os: "\u0438\u0440\u043E\u043D",
  pa: "\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40",
  pag: "Pangasinan",
  pam: "Kapampangan",
  pap: "Papiamentu",
  pcd: "Picard",
  pcm: "Naij\xE1",
  pdc: "Deitsch",
  pfl: "P\xE4lzisch",
  pi: "\u092A\u093E\u0932\u093F",
  pih: "Norfuk / Pitkern",
  pl: "polski",
  pms: "Piemont\xE8is",
  pnb: "\u067E\u0646\u062C\u0627\u0628\u06CC",
  pnt: "\u03A0\u03BF\u03BD\u03C4\u03B9\u03B1\u03BA\u03AC",
  ps: "\u067E\u069A\u062A\u0648",
  pt: "portugu\xEAs",
  pwn: "pinayuanan",
  qu: "Runa Simi",
  rm: "rumantsch",
  rmy: "romani \u010Dhib",
  rn: "ikirundi",
  ro: "rom\xE2n\u0103",
  "roa-rup": "arm\xE3neashti",
  "roa-tara": "tarand\xEDne",
  ru: "\u0440\u0443\u0441\u0441\u043A\u0438\u0439",
  rue: "\u0440\u0443\u0441\u0438\u043D\u044C\u0441\u043A\u044B\u0439",
  rw: "Ikinyarwanda",
  sa: "\u0938\u0902\u0938\u094D\u0915\u0943\u0924\u092E\u094D",
  sah: "\u0441\u0430\u0445\u0430 \u0442\u044B\u043B\u0430",
  sat: "\u1C65\u1C5F\u1C71\u1C5B\u1C5F\u1C72\u1C64",
  sc: "sardu",
  scn: "sicilianu",
  sco: "Scots",
  sd: "\u0633\u0646\u068C\u064A",
  se: "davvis\xE1megiella",
  sg: "S\xE4ng\xF6",
  sh: "srpskohrvatski / \u0441\u0440\u043F\u0441\u043A\u043E\u0445\u0440\u0432\u0430\u0442\u0441\u043A\u0438",
  shi: "Tacl\u1E25it",
  shn: "\u107D\u1083\u1087\u101E\u1083\u1087\u1010\u1086\u1038 ",
  shy: "tacawit",
  si: "\u0DC3\u0DD2\u0D82\u0DC4\u0DBD",
  simple: "Simple English",
  sk: "sloven\u010Dina",
  skr: "\u0633\u0631\u0627\u0626\u06CC\u06A9\u06CC",
  sl: "sloven\u0161\u010Dina",
  sm: "Gagana Samoa",
  smn: "anar\xE2\u0161kiel\xE2",
  sn: "chiShona",
  so: "Soomaaliga",
  sq: "shqip",
  sr: "\u0441\u0440\u043F\u0441\u043A\u0438 / srpski",
  srn: "Sranantongo",
  ss: "SiSwati",
  st: "Sesotho",
  stq: "Seeltersk",
  su: "Sunda",
  sv: "svenska",
  sw: "Kiswahili",
  szl: "\u015Bl\u016Fnski",
  szy: "Sakizaya",
  ta: "\u0BA4\u0BAE\u0BBF\u0BB4\u0BCD",
  tay: "Tayal",
  tcy: "\u0CA4\u0CC1\u0CB3\u0CC1",
  te: "\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41",
  tet: "tetun",
  tg: "\u0442\u043E\u04B7\u0438\u043A\u04E3",
  th: "\u0E44\u0E17\u0E22",
  ti: "\u1275\u130D\u122D\u129B",
  tk: "T\xFCrkmen\xE7e",
  tl: "Tagalog",
  tn: "Setswana",
  to: "lea faka-Tonga",
  tpi: "Tok Pisin",
  tr: "T\xFCrk\xE7e",
  trv: "Seediq",
  ts: "Xitsonga",
  tt: "\u0442\u0430\u0442\u0430\u0440\u0447\u0430 / tatar\xE7a",
  tum: "chiTumbuka",
  tw: "Twi",
  ty: "reo tahiti",
  tyv: "\u0442\u044B\u0432\u0430 \u0434\u044B\u043B",
  udm: "\u0443\u0434\u043C\u0443\u0440\u0442",
  ug: "\u0626\u06C7\u064A\u063A\u06C7\u0631\u0686\u06D5 / Uyghurche",
  uk: "\u0443\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430",
  ur: "\u0627\u0631\u062F\u0648",
  uz: "o\u02BBzbekcha / \u045E\u0437\u0431\u0435\u043A\u0447\u0430",
  ve: "Tshivenda",
  vec: "v\xE8neto",
  vep: "veps\xE4n kel\u2019",
  vi: "Ti\u1EBFng Vi\u1EC7t",
  vls: "West-Vlams",
  vo: "Volap\xFCk",
  wa: "walon",
  war: "Winaray",
  wo: "Wolof",
  wuu: "\u5434\u8BED",
  xal: "\u0445\u0430\u043B\u044C\u043C\u0433",
  xh: "isiXhosa",
  xmf: "\u10DB\u10D0\u10E0\u10D2\u10D0\u10DA\u10E3\u10E0\u10D8",
  yi: "\u05D9\u05D9\u05B4\u05D3\u05D9\u05E9",
  yo: "Yor\xF9b\xE1",
  yue: "\u7CB5\u8A9E",
  za: "Vahcuengh",
  zea: "Ze\xEAuws",
  zh: "\u4E2D\u6587",
  "zh-classical": "\u6587\u8A00",
  "zh-min-nan": "B\xE2n-l\xE2m-g\xFA",
  "zh-yue": "\u7CB5\u8A9E",
  zu: "isiZulu"
};

// src/utils/wikipediaAPI.ts
var import_obsidian = require("obsidian");
async function getArticles(query, languageCode, limit) {
  const url = getAPIBaseURL(languageCode) + `&action=opensearch&profile=fuzzy&redirects=resolve&limit=${limit != null ? limit : 10}&search=` + encodeURIComponent(query);
  const response = await fetchData(url);
  return response[1].map((title, index) => ({ title, url: response[3][index] }));
}
async function getArticleDescriptions(titles, languageCode) {
  const url = getAPIBaseURL(languageCode) + "&action=query&prop=description&titles=" + titlesToURLParameter(titles);
  const response = await fetchData(url);
  if (!response.query) return [];
  return sortResponsesByTitle(titles, Object.values(response.query.pages)).map(
    (page) => page.description || null
  );
}
async function getArticleIntros(titles, languageCode, cleanup) {
  const url = getAPIBaseURL(languageCode) + "&action=query&prop=extracts&exintro&explaintext&titles=" + titlesToURLParameter(titles);
  const response = await fetchData(url);
  if (!response.query) return [];
  return sortResponsesByTitle(titles, Object.values(response.query.pages)).map((page) => {
    var _a;
    const extract = (_a = page.extract.trim()) != null ? _a : null;
    if (extract && cleanup) {
      return extract.replaceAll(/{\\displaystyle [^\n]+}/g, (text) => "$" + text.slice(15, -1).trim() + "$").replaceAll("\n ", "").replaceAll(/  \S  /g, "").replaceAll(/  +/g, " ").replaceAll("\n ", "\n").replaceAll(" ,", ",").replaceAll(" :", ":").replaceAll("`", "\\`");
    }
    return extract;
  });
}
async function getArticleThumbnails(titles, languageCode) {
  const url = getAPIBaseURL(languageCode) + "&action=query&prop=pageimages&piprop=original|name&pilicense=any&titles=" + titlesToURLParameter(titles);
  const response = await fetchData(url);
  if (!response.query) return null;
  return sortResponsesByTitle(titles, Object.values(response.query.pages)).map(
    (page) => {
      var _a, _b;
      return (_b = (_a = page.original) == null ? void 0 : _a.source) != null ? _b : null;
    }
  );
}
function getAPIBaseURL(languageCode) {
  return `https://${languageCode}.wikipedia.org/w/api.php?format=json`;
}
function sortResponsesByTitle(titles, responses) {
  return responses.sort((a, b) => titles.indexOf(a.title) - titles.indexOf(b.title));
}
function titlesToURLParameter(titles) {
  return titles.map((title) => encodeURIComponent(title)).join("|");
}
async function fetchData(url) {
  var _a;
  const response = (_a = await (0, import_obsidian.requestUrl)(url).catch((e) => {
    console.error(e);
    return null;
  })) == null ? void 0 : _a.json;
  if (!response) return null;
  return response;
}

// src/utils/searchModal.ts
var SearchModal = class extends import_obsidian2.SuggestModal {
  constructor(app2, settings, editor) {
    super(app2);
    __publicField(this, "settings");
    __publicField(this, "editor");
    this.settings = settings;
    this.editor = editor;
    this.setPlaceholder("Search Wikipedia...");
  }
  onOpen() {
    var _a;
    super.onOpen();
    if (this.settings.autoSearchNoteTitle) {
      const fileName = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.basename;
      if (fileName && fileName != "") this.inputEl.value = fileName;
    }
    if (this.editor) {
      const selection = this.editor.getSelection();
      if (selection.trim() != "") this.inputEl.value = selection;
    }
    super.updateSuggestions();
  }
  renderSuggestion(article, el) {
    el.createEl("div", { text: article.title });
    el.createEl("small", {
      text: article.description || article.url.slice(8)
    });
  }
  async getSuggestions(query) {
    var _a, _b, _c;
    if (!window.navigator.onLine) {
      this.emptyStateText = "You have to be connected to the internet to search!";
      return [];
    }
    let languageCode = this.settings.language;
    const queryArgs = query.split(":", 2);
    if (queryArgs.length > 1) {
      const queryCode = (_a = queryArgs[0]) == null ? void 0 : _a.trim();
      const queryText = (_b = queryArgs[1]) == null ? void 0 : _b.trim();
      if (queryCode && Object.keys(languages).includes(queryCode) && queryCode !== languageCode) {
        languageCode = queryCode;
        query = queryText;
      }
    }
    if (query.trim() === "") {
      this.emptyStateText = "What are you waiting for? Start typing :)";
      return [];
    }
    this.emptyStateText = "No results found.";
    const searchResponses = await getArticles(query, languageCode, this.settings.searchLimit);
    const descriptions = await getArticleDescriptions(
      (_c = searchResponses == null ? void 0 : searchResponses.map((a) => a.title)) != null ? _c : [],
      languageCode
    );
    if (!searchResponses || !descriptions) {
      this.emptyStateText = "An error occurred... Go check the logs and create a bug report!";
      return [];
    }
    if (this.settings.autoInsertSingleResponseQueries && searchResponses.length === 1) {
      this.close();
      this.onChooseSuggestion({
        title: searchResponses[0].title,
        url: searchResponses[0].url,
        description: descriptions[0],
        languageCode
      });
    }
    return searchResponses.map((article, index) => ({
      title: article.title,
      url: article.url,
      description: descriptions[index],
      languageCode
    }));
  }
};

// src/utils/templateModal.ts
var import_obsidian3 = require("obsidian");
var TemplateModal = class extends import_obsidian3.SuggestModal {
  constructor(app2, settings, editor, article, noteTemplatesOnly = false) {
    super(app2);
    __publicField(this, "settings");
    __publicField(this, "editor");
    __publicField(this, "article");
    __publicField(this, "noteTemplatesOnly");
    this.settings = settings;
    this.editor = editor;
    this.article = article;
    this.noteTemplatesOnly = noteTemplatesOnly;
    this.setPlaceholder("Pick a template...");
  }
  renderSuggestion(template, el) {
    el.createEl("div", {
      text: `${template.name} ${this.noteTemplatesOnly ? "" : template.createNote ? "(note)" : "(inline)"}`
    });
    if (template.createNote && template.useTemplateFile) {
      const file = app.vault.getAbstractFileByPath(template.templateFilePath);
      if (file && file instanceof import_obsidian3.TFile) {
        el.createEl("small", {
          text: `File: ${template.templateFilePath}`
        });
      } else {
        el.createEl("small", {
          text: `Template file '${template.templateFilePath}' not found!`
        });
      }
    } else {
      el.createEl("small", {
        text: template.templateString.replaceAll("\n", "\\n")
      });
    }
  }
  async getSuggestions(query) {
    return (this.noteTemplatesOnly ? this.settings.templates.filter((template) => template.createNote) : this.settings.templates).filter((template) => template.name.toLowerCase().includes(query.toLowerCase()));
  }
};

// src/utils/generateInsert.ts
var import_obsidian4 = require("obsidian");
async function generateInsert(settings, article, content, selection) {
  var _a, _b, _c, _d, _e;
  const title = settings.prioritizeArticleTitle || selection === "" ? article.title : selection;
  let insert = content.replaceAll("{title}", title).replaceAll("{url}", article.url).replaceAll("{description}", (_a = article.description) != null ? _a : "").replaceAll("{language}", languages[article.languageCode]).replaceAll("{languageCode}", article.languageCode);
  if (content.includes("{intro}")) {
    const intro = (_c = (_b = await getArticleIntros([article.title], settings.language, settings.cleanupIntros)) == null ? void 0 : _b[0]) != null ? _c : null;
    insert = insert.replaceAll("{intro}", intro != null ? intro : "");
    if (!intro) new import_obsidian4.Notice("Could not fetch the articles introduction.");
  }
  if (content.includes("{thumbnail}") || content.includes("{thumbnailUrl}")) {
    const thumbnailUrl = (_e = (_d = await getArticleThumbnails([article.title], settings.language)) == null ? void 0 : _d[0]) != null ? _e : null;
    insert = insert.replaceAll(
      "{thumbnail}",
      thumbnailUrl ? `![${article.title} Thumbnail${settings.thumbnailWidth ? ` | ${settings.thumbnailWidth}` : ""}](${thumbnailUrl})` : ""
    ).replaceAll("{thumbnailUrl}", thumbnailUrl != null ? thumbnailUrl : "");
    if (!thumbnailUrl) new import_obsidian4.Notice("Could not fetch the articles thumbnail.");
  }
  if (content.includes("{description}") && !article.description)
    new import_obsidian4.Notice("The article has no description.");
  let cursorPosition = insert.search("{cursor}");
  cursorPosition = cursorPosition != -1 ? cursorPosition : null;
  insert = insert.replaceAll("{cursor}", "");
  return { insert, cursorPosition };
}

// src/utils/createNote.ts
var import_obsidian5 = require("obsidian");
var createNoteInActiveNotesFolderMarker = "[current folder]";
async function createNoteInFolder(app2, title, content, folderPath, overrideExisting) {
  if (!await app2.vault.adapter.exists(folderPath) || app2.vault.getAbstractFileByPath(folderPath) instanceof import_obsidian5.TFile) {
    new import_obsidian5.Notice(
      "Aborted! The folder you specified in the settings to create this new note in does not exist. Please visit the plugin settings and change the path!",
      15e3
    );
    return null;
  }
  const sanitizedTitle = title.replaceAll(`"`, `'`).replace(/[\\/:*?]/g, "~");
  const filePath = (0, import_obsidian5.normalizePath)(`${folderPath}/${sanitizedTitle}.md`);
  const file = app2.vault.getAbstractFileByPath(filePath);
  if (file && !overrideExisting) {
    new import_obsidian5.Notice(`Aborted! '${filePath}' already exists.`);
    return null;
  } else if (file && overrideExisting) {
    await app2.vault.modify(file, content);
    new import_obsidian5.Notice(`Note successfully overwritten.`);
    return filePath;
  } else {
    await app2.vault.create(filePath, content);
    new import_obsidian5.Notice("New note created successfully.");
    return filePath;
  }
}

// src/commands/linkArticles.ts
var LinkArticleModal = class extends SearchModal {
  async onChooseSuggestion(article) {
    if (this.settings.templates.length > 1) {
      new LinkArticleTemplateModal(app, this.settings, this.editor, article).open();
    } else {
      linkArticle(this.app, this.editor, this.settings, article, this.settings.templates[0]);
    }
  }
};
var LinkArticleTemplateModal = class extends TemplateModal {
  async onChooseSuggestion(template) {
    linkArticle(this.app, this.editor, this.settings, this.article, template);
  }
};
async function linkArticle(app2, editor, settings, article, template) {
  var _a, _b;
  let templateString = template.templateString;
  const selection = editor.getSelection();
  if (template.createNote) {
    if (template.useTemplateFile) {
      const templateFile = app2.vault.getAbstractFileByPath(template.templateFilePath);
      if (!templateFile || !(templateFile instanceof import_obsidian6.TFile)) {
        new import_obsidian6.Notice(`Aborting! Template file '${template.templateFilePath}' not found!`);
        return;
      }
      templateString = await app2.vault.read(templateFile);
    }
    const content = await generateInsert(settings, article, templateString, selection);
    let folderPath = template.customPath === "" ? settings.defaultNotePath : template.customPath;
    if (folderPath === createNoteInActiveNotesFolderMarker) {
      folderPath = ((_b = (_a = app2.workspace.getActiveFile()) == null ? void 0 : _a.parent) == null ? void 0 : _b.path) || null;
      if (folderPath == null) {
        new import_obsidian6.Notice(
          "Aborted! You have to have an active file to create a note in the current files parent folder."
        );
        return;
      }
    }
    const notePath = await createNoteInFolder(
      app2,
      article.title,
      content.insert,
      folderPath,
      settings.overrideFiles
    );
    if (notePath == null) return;
    editor.replaceSelection(
      `[[${notePath}|${settings.prioritizeArticleTitle || selection === "" ? article.title : selection}]]`
    );
  } else {
    const internalCursorMarker = "{cursorMarker}";
    let content = editor.getValue();
    content = content.substring(0, editor.posToOffset(editor.getCursor("from"))) + templateString + internalCursorMarker + content.substring(editor.posToOffset(editor.getCursor("to")));
    const result = await generateInsert(settings, article, content, selection);
    let newContent = result.insert;
    let cursorPosition = result.cursorPosition;
    if (cursorPosition == null) cursorPosition = newContent.search(internalCursorMarker);
    newContent = newContent.replace(internalCursorMarker, "");
    editor.setValue(newContent);
    const cursorPos = editor.offsetToPos(cursorPosition);
    editor.setCursor(cursorPos);
    editor.scrollIntoView({ from: cursorPos, to: cursorPos }, true);
  }
}

// src/settings.ts
var import_obsidian10 = require("obsidian");

// src/utils/suggesters/folderSuggest.ts
var import_obsidian8 = require("obsidian");

// src/utils/suggesters/suggest.ts
var import_obsidian7 = require("obsidian");

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/utils/suggesters/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    __publicField(this, "owner");
    __publicField(this, "values");
    __publicField(this, "suggestions");
    __publicField(this, "selectedItem");
    __publicField(this, "containerEl");
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on("click", ".suggestion-item", this.onSuggestionClick.bind(this));
    containerEl.on("mousemove", ".suggestion-item", this.onSuggestionMouseover.bind(this));
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(selectedIndex, this.suggestions.length);
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app2, inputEl) {
    __publicField(this, "inputEl");
    __publicField(this, "app");
    __publicField(this, "popper");
    __publicField(this, "scope");
    __publicField(this, "suggestEl");
    __publicField(this, "suggest");
    this.inputEl = inputEl;
    this.app = app2;
    this.scope = new import_obsidian7.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on("mousedown", ".suggestion-container", (event) => {
      event.preventDefault();
    });
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper) this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/utils/suggesters/folderSuggest.ts
var FolderSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    folders.push(createNoteInActiveNotesFolderMarker);
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian8.TFolder) {
        const path = folder.path === "/" ? "/" : "/" + folder.path;
        if (path.toLowerCase().contains(lowerCaseInputStr)) {
          folders.push(path);
        }
      }
    });
    folders.sort((a, b) => a.localeCompare(b));
    return folders;
  }
  renderSuggestion(folderPath, el) {
    el.setText(folderPath);
  }
  selectSuggestion(folderPath) {
    this.inputEl.value = folderPath;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/utils/suggesters/fileSuggest.ts
var import_obsidian9 = require("obsidian");
var FileSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const files = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((file) => {
      if (file instanceof import_obsidian9.TFile && file.path.toLowerCase().contains(lowerCaseInputStr)) {
        files.push(file);
      }
    });
    return files;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings.ts
var DEFAULT_TEMPLATE_STRING_INLINE = "[{title}]({url})";
var DEFAULT_TEMPLATE_STRING_NOTE = "{thumbnail}\n[{title}]({url}): {intro}";
var DEFAULT_TEMPLATE = {
  name: "Default",
  templateString: DEFAULT_TEMPLATE_STRING_INLINE,
  createNote: false,
  customPath: "",
  useTemplateFile: false,
  templateFilePath: ""
};
var DEFAULT_SETTINGS = {
  language: "en",
  searchLimit: 10,
  thumbnailWidth: NaN,
  defaultNotePath: "/",
  templates: [DEFAULT_TEMPLATE],
  autoInsertSingleResponseQueries: false,
  autoSearchNoteTitle: false,
  prioritizeArticleTitle: false,
  cleanupIntros: true,
  openArticleInFullscreen: false,
  openArticlesInBrowser: false,
  openCreatedNotes: false,
  overrideFiles: false,
  showedSurfingMessage: false
};
var WikipediaSearchSettingTab = class extends import_obsidian10.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    __publicField(this, "plugin");
    __publicField(this, "settings");
    this.plugin = plugin;
    this.settings = plugin.settings;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const fragment = new DocumentFragment();
    fragment.createEl("span").innerHTML = "Wikipedia Search Settings > Read the <a href='https://strangegirlmurph.github.io/obsidian-wikipedia-search/'>documentation</a>!";
    new import_obsidian10.Setting(containerEl).setName(fragment).setHeading();
    new import_obsidian10.Setting(containerEl).setName("Language").setDesc("The default Wikipedia to browse.").addDropdown(
      (dropdown) => dropdown.addOptions(
        Object.entries(languages).reduce(
          (pre, lang) => ({
            ...pre,
            [lang[0]]: `${lang[0]} - ${lang[1]}`
          }),
          {}
        )
      ).setValue(this.settings.language).onChange(async (value) => {
        this.settings.language = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Search limit").setDesc("Maximum number of search results to show. (1\u2264limit\u2264500)").addText(
      (text) => text.setPlaceholder("limit").setValue(this.settings.searchLimit ? this.settings.searchLimit.toString() : "").onChange(async (value) => {
        const parsed = parseInt(value);
        if (parsed < 1 || parsed > 500) return;
        this.settings.searchLimit = parsed;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Thumbnail width").setDesc("The width of the thumbnails in pixels. (Leave empty to use the original size.)").addText(
      (text) => text.setPlaceholder("width").setValue(this.settings.thumbnailWidth ? this.settings.thumbnailWidth.toString() : "").onChange(async (value) => {
        const parsed = parseInt(value);
        if (typeof parsed !== "number") return;
        this.settings.thumbnailWidth = parsed;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(this.containerEl).setName("Default note path").setDesc("Default folder where notes should be created.").addSearch((search) => {
      new FolderSuggest(this.app, search.inputEl);
      return search.setPlaceholder("Example: folder/subfolder").setValue(this.settings.defaultNotePath).onChange(async (newFolder) => {
        if (newFolder.length == 0) {
          this.settings.defaultNotePath = DEFAULT_SETTINGS.defaultNotePath;
          search.setValue(this.settings.defaultNotePath);
        } else {
          this.settings.defaultNotePath = newFolder;
        }
        await this.plugin.saveSettings();
      });
    });
    const templateSettings = new DocumentFragment();
    templateSettings.createEl("span").innerHTML = "Templates (<a href='https://strangegirlmurph.github.io/obsidian-wikipedia-search/settings.html#template-settings'>Guide</a>)";
    new import_obsidian10.Setting(containerEl).setName(templateSettings).setHeading();
    this.addTemplateSettings(containerEl);
    new import_obsidian10.Setting(containerEl).setName("Workflow optimizations").setHeading();
    new import_obsidian10.Setting(containerEl).setName("Auto-search note title").setDesc("Whether or not to automatically use the active notes title when searching for articles and nothing is selected.").addToggle(
      (toggle) => toggle.setValue(this.settings.autoSearchNoteTitle).onChange(async (value) => {
        this.settings.autoSearchNoteTitle = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Auto-select single response queries").setDesc(
      "Whether or not to automatically select the response to a query when there is only one article to choose from."
    ).addToggle(
      (toggle) => toggle.setValue(this.settings.autoInsertSingleResponseQueries).onChange(async (value) => {
        this.settings.autoInsertSingleResponseQueries = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Use article title instead of selection").setDesc(
      "When hyperlinking: Whether or not to use the articles title instead of the selected text for the '{title}' tag of your template."
    ).addToggle(
      (toggle) => toggle.setValue(this.settings.prioritizeArticleTitle).onChange(async (value) => {
        this.settings.prioritizeArticleTitle = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Stop auto-cleanup of intros").setDesc("Whether or not to stop auto-cleaning the articles intros for better readability.").addToggle(
      (toggle) => toggle.setValue(!this.settings.cleanupIntros).onChange(async (value) => {
        this.settings.cleanupIntros = !value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Open article in browser").setDesc(
      "Whether or not to open articles in the browser instead of in-app if the Surfing plugin is installed and enabled."
    ).addToggle(
      (toggle) => toggle.setValue(this.settings.openArticlesInBrowser).onChange(async (value) => {
        this.settings.openArticlesInBrowser = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Article tab placement").setDesc(
      "Whether or not to open articles in a fullscreen tab instead of a split view when using the Surfing plugin or creating an article note."
    ).addToggle(
      (toggle) => toggle.setValue(this.settings.openArticleInFullscreen).onChange(async (value) => {
        this.settings.openArticleInFullscreen = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Open created article notes").setDesc("Whether or not to open the newly created article notes after creating them.").addToggle(
      (toggle) => toggle.setValue(this.settings.openCreatedNotes).onChange(async (value) => {
        this.settings.openCreatedNotes = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Override files").setDesc("Whether or not to override existing files when creating article notes.").addToggle(
      (toggle) => toggle.setValue(this.settings.overrideFiles).onChange(async (value) => {
        this.settings.overrideFiles = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Feedback, bug reports and feature requests \u{1F33F}").setHeading();
    const appendix = `<p style="border-top:1px solid var(--background-modifier-border); padding: 0.75em 0; margin: unset;">If you have any kind of feedback, please let me know! No matter how small! I want to make this plugin as useful as possible for everyone and the only way I can improve this plugin for you is if you tell me about it. I love to hear about your ideas for new features, all the bugs you found and everything that annoys you. Don't be shy! I can also obsess a lot about small details. Just <a href="https://github.com/StrangeGirlMurph/obsidian-wikipedia-search/issues/new/choose">create an issue on GitHub</a> or <a href="mailto:work@murphy-in.space">write me an email</a> and I'll get back to you ASAP. ~ Murphy :)</p>
		<p style="margin: unset;">PS: Wikipedia also has a dark mode for everyone with an account.</p>`;
    const div = containerEl.createEl("div");
    div.innerHTML = appendix;
  }
  addTemplateSettings(containerEl) {
    for (let [i, template] of this.settings.templates.entries()) {
      const isDefaultTemplate = i == 0;
      let setting = new import_obsidian10.Setting(containerEl);
      setting.settingEl.removeChild(setting.infoEl);
      setting.controlEl.style.flexWrap = "wrap";
      setting.controlEl.style.justifyContent = "center";
      setting.addText((text) => {
        if (isDefaultTemplate) text.setDisabled(true);
        return text.setPlaceholder("Name").setValue(isDefaultTemplate ? "Default Template" : template.name).onChange(async (value) => {
          template.name = value;
          await this.plugin.saveSettings();
        });
      });
      setting.controlEl.children[setting.controlEl.children.length - 1].setAttr("style", "width: 140px;");
      setting.addToggle(
        (toggle) => toggle.setTooltip("creates a note").setValue(template.createNote).onChange(async (value) => {
          template.createNote = value;
          if (template.createNote && (template.templateString == DEFAULT_TEMPLATE_STRING_INLINE || template.templateString === "")) {
            template.templateString = DEFAULT_TEMPLATE_STRING_NOTE;
          } else if (!template.createNote && (template.templateString == DEFAULT_TEMPLATE_STRING_NOTE || template.templateString === "")) {
            template.templateString = DEFAULT_TEMPLATE_STRING_INLINE;
          }
          await this.plugin.saveSettings();
          this.display();
        })
      );
      const firstGroup = setting.controlEl.createDiv();
      firstGroup.setAttr("style", "display:flex;gap:var(--size-4-2);align-items:center;");
      firstGroup.appendChild(setting.controlEl.children[0]);
      firstGroup.appendChild(setting.controlEl.children[0]);
      if (template.createNote) {
        setting.addSearch((search) => {
          new FolderSuggest(this.app, search.inputEl);
          search.setPlaceholder("custom note path").setValue(template.customPath).onChange(async (newFolder) => {
            template.customPath = newFolder;
            await this.plugin.saveSettings();
          });
        });
        setting.controlEl.children[setting.controlEl.children.length - 1].setAttr(
          "style",
          "flex-grow:1;width:170px;"
        );
        setting.addToggle(
          (toggle) => toggle.setTooltip("uses a template file").setValue(template.useTemplateFile).onChange(async (value) => {
            template.useTemplateFile = value;
            await this.plugin.saveSettings();
            this.display();
          })
        );
        const secondGroup = setting.controlEl.createDiv();
        secondGroup.setAttr("style", "display:flex;flex-grow:1;gap:var(--size-4-2);align-items:center;");
        secondGroup.appendChild(setting.controlEl.children[1]);
        secondGroup.appendChild(setting.controlEl.children[1]);
      }
      if (template.useTemplateFile && template.createNote) {
        setting.addSearch((search) => {
          new FileSuggest(this.app, search.inputEl);
          search.setPlaceholder("template file path").setValue(template.templateFilePath).onChange(async (newFolder) => {
            template.templateFilePath = newFolder;
            await this.plugin.saveSettings();
          });
        });
        setting.controlEl.children[setting.controlEl.children.length - 1].setAttr(
          "style",
          "flex-grow:1;width:170px;"
        );
      } else {
        setting.addTextArea((text) => {
          text.inputEl.setAttr(
            "style",
            "white-space:pre;overflow-wrap:normal;overflow:hidden;resize:none;flex-grow:1;width:220px;"
          );
          text.inputEl.setAttr("rows", template.createNote ? "3" : "2");
          return text.setPlaceholder("template string").setValue(template.templateString).onChange(async (value) => {
            template.templateString = value;
            await this.plugin.saveSettings();
          });
        });
      }
      setting.addExtraButton((button) => {
        if (isDefaultTemplate) button.setDisabled(true);
        button.extraSettingsEl.style.height = "min-content";
        return button.setTooltip("delete template").setIcon("minus").onClick(async () => {
          this.settings.templates.splice(i, 1);
          await this.plugin.saveSettings();
          this.display();
        });
      });
      const thirdGroup = setting.controlEl.createDiv();
      thirdGroup.setAttr("style", "display:flex;flex-grow:1;gap:var(--size-4-2);align-items:center;");
      thirdGroup.appendChild(setting.controlEl.children[setting.controlEl.children.length - 3]);
      thirdGroup.appendChild(setting.controlEl.children[setting.controlEl.children.length - 2]);
    }
    new import_obsidian10.Setting(containerEl).addExtraButton(
      (button) => button.setTooltip("add template").setIcon("plus").onClick(async () => {
        if (this.settings.templates.length == 21)
          return new import_obsidian10.Notice(
            "Easy buddy... I need to stop you right there. You can only have up to 20 templates. It's for your own good! (I think) If you really need more write me. If you convince me I'll let you have more.",
            15e3
          );
        this.settings.templates.push({
          ...DEFAULT_TEMPLATE,
          name: `Additional Template`
        });
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
};

// src/commands/openArticles.ts
var import_obsidian11 = require("obsidian");
var OpenArticleModal = class extends SearchModal {
  constructor(plugin, settings) {
    super(app, settings);
    __publicField(this, "workspace");
    __publicField(this, "plugin");
    this.workspace = app.workspace;
    this.plugin = plugin;
  }
  async onChooseSuggestion(article) {
    if (
      // @ts-expect-error undocumented
      app.plugins.enabledPlugins.has("surfing") && !this.settings.openArticlesInBrowser && import_obsidian11.Platform.isDesktopApp
    ) {
      app.workspace.getLeaf(this.settings.openArticleInFullscreen ? "tab" : "split").setViewState({
        type: "surfing-view",
        active: true,
        state: { url: article.url }
      });
    } else if (!this.settings.showedSurfingMessage && import_obsidian11.Platform.isDesktopApp && !this.settings.openArticlesInBrowser) {
      const modal = new import_obsidian11.Modal(app);
      modal.onClose = () => this.onChooseSuggestion(article);
      modal.titleEl.setText("Wikipedia Search plugin \u2665 Surfing plugin");
      modal.contentEl.innerHTML = `The Wikipedia Search plugin integrates with the amazing Surfing plugin to enable you to open Wikipedia articles directly inside of Obsidian! You just need to install and enable it. It has tons of awesome features and does the heavy lifting of loading the website itself in Obsidian. In this case the Wikipedia Search plugin just provides the search functionality. Using the Surfing plugin is completely optional but I highly recommend you check it out! Note: This will only be shown to you once but you can always find the information later in the README on GitHub as well. ~ Murphy :)<br><br>
			<b>tl;dr: Install and enable the amazing <a href="obsidian://show-plugin?id=surfing">Surfing plugin</a> to open Wikipedia articles directly inside of Obsidian!</b>`;
      modal.open();
      this.settings.showedSurfingMessage = true;
      this.plugin.saveSettings();
    } else {
      window.open(article.url, "_blank");
    }
  }
};

// src/utils/wikipediaIcon.ts
var wikipediaIcon = `<path fill="currentColor"" d="M 75.679688 18.679688 L 75.679688 20.351562 C 73.472656 20.742188 71.804688 21.433594 70.671875 22.425781 C 69.050781 23.902344 67.136719 26.160156 65.882812 29.203125 L 40.347656 81.320312 L 38.648438 81.320312 L 13.011719 28.523438 C 11.820312 25.816406 10.195312 24.160156 9.707031 23.558594 C 8.941406 22.625 8 21.894531 6.882812 21.367188 C 5.765625 20.839844 4.257812 20.5 2.359375 20.351562 L 2.359375 18.679688 L 27.304688 18.679688 L 27.304688 20.351562 C 24.425781 20.621094 23.054688 21.101562 22.195312 21.796875 C 21.339844 22.488281 20.910156 23.375 20.910156 24.460938 C 20.910156 25.964844 21.613281 28.3125 23.023438 31.503906 L 41.953125 67.410156 L 60.464844 31.957031 C 61.902344 28.464844 63.097656 26.039062 63.097656 24.6875 C 63.097656 23.8125 62.652344 22.976562 61.765625 22.179688 C 60.878906 21.382812 59.871094 20.816406 57.761719 20.484375 C 57.609375 20.457031 57.347656 20.410156 56.980469 20.351562 L 56.980469 18.679688 Z M 75.679688 18.679688 "/>
<path fill="currentColor" d="M 97.640625 18.679688 L 97.640625 20.351562 C 95.4375 20.742188 93.769531 21.433594 92.636719 22.425781 C 91.011719 23.902344 89.101562 26.160156 87.84375 29.203125 L 65.433594 81.320312 L 63.734375 81.320312 L 40.054688 28.523438 C 38.859375 25.816406 37.234375 24.160156 36.746094 23.558594 C 35.980469 22.625 35.039062 21.894531 33.921875 21.367188 C 32.804688 20.839844 31.792969 20.5 29.894531 20.351562 L 29.894531 18.679688 L 54.34375 18.679688 L 54.34375 20.351562 C 51.464844 20.621094 50.09375 21.101562 49.238281 21.796875 C 48.378906 22.488281 47.949219 23.375 47.949219 24.460938 C 47.949219 25.964844 48.65625 28.3125 50.0625 31.503906 L 67.042969 67.410156 L 82.425781 31.957031 C 83.863281 28.464844 85.058594 26.039062 85.058594 24.6875 C 85.058594 23.8125 84.613281 22.976562 83.726562 22.179688 C 82.839844 21.382812 81.339844 20.816406 79.226562 20.484375 C 79.074219 20.457031 78.8125 20.410156 78.445312 20.351562 L 78.445312 18.679688 Z M 97.640625 18.679688 "/>`;

// src/commands/createArticleNotes.ts
var import_obsidian12 = require("obsidian");
var CreateArticleNoteModal = class extends SearchModal {
  async onChooseSuggestion(article) {
    const templates = this.settings.templates.filter((template) => template.createNote);
    if (templates.length > 1) {
      new CreateArticleNoteTemplateModal(this.app, this.settings, this.editor, article, true).open();
    } else {
      createArticleNote(this.app, this.settings, article, templates[0]);
    }
  }
};
var CreateArticleNoteTemplateModal = class extends TemplateModal {
  async onChooseSuggestion(template) {
    createArticleNote(this.app, this.settings, this.article, template);
  }
};
async function createArticleNote(app2, settings, article, template) {
  var _a, _b;
  let templateString = template.templateString;
  if (template.useTemplateFile) {
    const templateFile = app2.vault.getAbstractFileByPath(template.templateFilePath);
    if (!templateFile || !(templateFile instanceof import_obsidian12.TFile)) {
      new import_obsidian12.Notice(`Aborting! Template file '${template.templateFilePath}' not found!`);
      return;
    }
    templateString = await app2.vault.read(templateFile);
  }
  let folderPath = template.customPath === "" ? settings.defaultNotePath : template.customPath;
  if (folderPath === createNoteInActiveNotesFolderMarker) {
    folderPath = ((_b = (_a = app2.workspace.getActiveFile()) == null ? void 0 : _a.parent) == null ? void 0 : _b.path) || null;
    if (folderPath == null) {
      new import_obsidian12.Notice(
        "Aborted! You have to have an active file to create a note in the current files parent folder."
      );
      return;
    }
  }
  const result = await generateInsert(settings, article, templateString, "");
  const filePath = await createNoteInFolder(
    app2,
    article.title,
    result.insert,
    folderPath,
    settings.overrideFiles
  );
  if (!filePath) return;
  if (settings.openCreatedNotes) {
    app2.workspace.getLeaf(settings.openArticleInFullscreen ? "tab" : "split").openFile(app2.vault.getAbstractFileByPath(filePath));
  }
}

// src/main.ts
var WikipediaSearchPlugin = class extends import_obsidian13.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
  }
  async onload() {
    console.log("loading wikipedia-search plugin");
    await this.loadSettings();
    this.addCommand({
      id: "link-article",
      name: "Link Article",
      editorCallback: (editor) => {
        new LinkArticleModal(this.app, this.settings, editor).open();
      }
    });
    this.addCommand({
      id: "open-article",
      name: "Open Article",
      callback: () => new OpenArticleModal(this, this.settings).open()
    });
    this.addCommand({
      id: "create-article-note",
      name: "Create Article Note",
      callback: () => {
        if (this.settings.templates.filter((template) => template.createNote).length === 0) {
          new import_obsidian13.Notice("To use this command you have to create a note template first!");
          return;
        }
        new CreateArticleNoteModal(this.app, this.settings).open();
      }
    });
    (0, import_obsidian13.addIcon)("wikipedia", wikipediaIcon);
    this.addRibbonIcon("wikipedia", "Open Article", () => new OpenArticleModal(this, this.settings).open());
    this.addSettingTab(new WikipediaSearchSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    const settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if ("defaultTemplate" in settings) {
      settings.templates.unshift(
        Object.assign(DEFAULT_TEMPLATE, { templateString: settings.defaultTemplate })
      );
      Object.keys(settings).forEach((key) => {
        if (!(key in DEFAULT_SETTINGS)) delete settings[key];
      });
    }
    this.settings = settings;
    this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
